# Intuition
The problem requires finding the nth ugly number, where ugly numbers are positive integers whose prime factors are limited to 2, 3, and 5. The key observation is that every ugly number can be generated by multiplying a previous ugly number by 2, 3, or 5.

# Approach
To solve the problem, we can use dynamic programming by maintaining an array `ugly` where `ugly[i]` stores the ith ugly number. We start with the first ugly number as 1. We then generate subsequent ugly numbers by taking the minimum of the next multiples of 2, 3, and 5. We maintain three indices `i2`, `i3`, and `i5`, which point to the smallest ugly numbers that need to be multiplied by 2, 3, and 5, respectively. As we find the minimum, we update the corresponding index and the next multiple for that index.

# Complexity
- **Time complexity:**  
  The time complexity is $$O(n)$$ because we generate each of the first `n` ugly numbers exactly once.
  
- **Space complexity:**  
  The space complexity is $$O(n)$$ as we need to store the first `n` ugly numbers in the `ugly` array.

# Code
```c
int min(int a, int b, int c) {
    if (a < b) {
        return (a < c) ? a : c;
    } else {
        return (b < c) ? b : c;
    }
}

int nthUglyNumber(int n) {
    int ugly[n];
    ugly[0] = 1;
    
    int i2 = 0, i3 = 0, i5 = 0;
    int next_multiple_of_2 = 2;
    int next_multiple_of_3 = 3;
    int next_multiple_of_5 = 5;
    int next_ugly_number = 1;

    for (int i = 1; i < n; i++) {
        next_ugly_number = min(next_multiple_of_2, next_multiple_of_3, next_multiple_of_5);
        ugly[i] = next_ugly_number;

        if (next_ugly_number == next_multiple_of_2) {
            i2++;
            next_multiple_of_2 = ugly[i2] * 2;
        }
        if (next_ugly_number == next_multiple_of_3) {
            i3++;
            next_multiple_of_3 = ugly[i3] * 3;
        }
        if (next_ugly_number == next_multiple_of_5) {
            i5++;
            next_multiple_of_5 = ugly[i5] * 5;
        }
    }

    return next_ugly_number;
}
```
